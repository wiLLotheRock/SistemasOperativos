

================================================================================
XV6 SISTEMA OPERATIVO
================================================================================

INTEGRANTES:

WILBERT RAÚL COPAJA HUAYTA 2O23-119016

DESCRIPCIÓN DEL PROYECTO:

xv6 es un sistema operativo educativo desarrollado por el MIT como una 
reimplementación moderna de Unix Version 6. Este proyecto extiende xv6 con
tres módulos de instrumentación, monitoreo y análisis del sistema operativo,
diseñados para facilitar el estudio y comprensión de conceptos fundamentales
de sistemas operativos.

EXTENSIONES IMPLEMENTADAS:

1. Sistema de Instrumentación de Syscalls (trace)
   - Trazado en tiempo real de llamadas al sistema por proceso
   - Muestra nombre de syscall, argumentos y valor de retorno
   - Aislamiento por proceso sin afectar el resto del sistema

2. Comandos de Monitoreo del Sistema (uptime, ps, lsx)
   - uptime: Estadísticas del sistema (tiempo, procesos, context switches)
   - ps: Inspector de procesos (PID, estado, memoria, nombre)
   - lsx: Listado extendido de archivos (tipo, inode, links, tamaño)

3. Contador de Invocaciones de Syscalls (syscount)
   - Contabilidad global de invocaciones por syscall desde el boot
   - Consulta individual o resumen completo de estadísticas
   - Análisis cuantitativo del comportamiento del sistema

CARACTERÍSTICAS TÉCNICAS:

- 4 nuevas syscalls implementadas (trace, sysinfo, getprocs, syscount)
- 5 comandos de usuario agregados
- ~850 líneas de código nuevo/modificado
- Compatible con GCC moderno y distribuciones Linux actuales
- Documentación completa en informe.md

================================================================================
INSTRUCCIONES DE COMPILACIÓN Y EJECUCIÓN
================================================================================

REQUISITOS DEL SISTEMA:

- Sistema operativo: Linux (Ubuntu, Debian, Fedora, Arch, etc.)
- Compilador: GCC 7 o superior
- Emulador: QEMU (qemu-system-i386)
- Herramientas: make, objcopy, objdump

INSTALACIÓN DE DEPENDENCIAS:

  Ubuntu/Debian:
    $ sudo apt-get update
    $ sudo apt-get install build-essential qemu-system-x86 gdb

  Fedora:
    $ sudo dnf install gcc make qemu-system-x86 gdb

  Arch Linux:
    $ sudo pacman -S base-devel qemu gdb

COMPILACIÓN:

  1. Limpiar compilaciones anteriores (recomendado):
     $ make clean

  2. Compilar el kernel y programas de usuario:
     $ make

     Esto generará:
     - kernel: Imagen del kernel de xv6
     - fs.img: Sistema de archivos con todos los programas
     - *.o: Archivos objeto compilados

  3. Si hay errores de compilación, verificar versión de GCC:
     $ gcc --version
     (Debe ser 7.0 o superior)

EJECUCIÓN:

  Opción 1 - Modo gráfico (con ventana QEMU):
    $ make qemu

  Opción 2 - Modo texto (recomendado para servidores sin X11):
    $ make qemu-nox

  Opción 3 - Con soporte GDB para debugging:
    $ make qemu-gdb
    (En otra terminal: $ gdb kernel, luego: (gdb) target remote localhost:26000)

SALIR DE QEMU:

  - Presionar: Ctrl+A, luego soltar y presionar X
  - O cerrar la ventana del emulador (si está en modo gráfico)

USO DE LOS COMANDOS:

  Una vez dentro de xv6 (verás el prompt '$'), puedes ejecutar:

  # Trazado de syscalls
  $ trace echo hola
  $ trace ls
  $ trace cat README

  # Monitoreo del sistema
  $ uptime
  $ ps
  $ lsx

  # Contador de syscalls
  $ syscount           # Ver todos los contadores
  $ syscount 16        # Ver contador de syscall #16 (write)

  # Comandos estándar de xv6
  $ ls                 # Listar archivos
  $ cat README         # Mostrar contenido de archivo
  $ mkdir test         # Crear directorio
  $ echo hola          # Imprimir texto
  $ grep xv6 README    # Buscar en archivo

VERIFICACIÓN DE FUNCIONAMIENTO:

  1. Compilar sin errores:
     $ make clean && make
     (No debe mostrar errores, solo warnings menores)

  2. Ejecutar y verificar boot:
     $ make qemu-nox
     (Debe mostrar "init: starting sh" y el prompt '$')

  3. Probar cada entregable:
     $ trace echo test      # Debe mostrar syscalls
     $ uptime               # Debe mostrar estadísticas
     $ ps                   # Debe listar procesos
     $ lsx                  # Debe mostrar archivos con detalles
     $ syscount             # Debe mostrar tabla de contadores

SOLUCIÓN DE PROBLEMAS:

  Problema: "make: qemu-system-i386: Command not found"
  Solución: Instalar QEMU (ver sección de dependencias arriba)

  Problema: "panic: init exiting"
  Solución: El sistema ya está corregido. Si persiste, ejecutar:
            $ make clean && make

  Problema: Kernel muy grande (>100MB)
  Solución: Ya está resuelto en el Makefile con flags apropiados

  Problema: Warnings sobre recursión infinita en sh.c
  Solución: Es normal, se suprime con -Wno-infinite-recursion

ESTRUCTURA DEL PROYECTO:

  Archivos del Kernel:
    - kernel.ld        : Linker script del kernel
    - main.c           : Inicialización del kernel
    - proc.c/proc.h    : Gestión de procesos
    - syscall.c/h      : Manejador de syscalls
    - sysproc.c        : Implementación de syscalls de procesos
    - trap.c           : Manejo de interrupciones y traps

  Comandos de Usuario (nuevos):
    - trace.c          : Comando para trazado de syscalls
    - uptime.c         : Comando para estadísticas del sistema
    - ps.c             : Comando para listar procesos
    - lsx.c            : Comando para listado extendido de archivos
    - syscount.c       : Comando para consultar contadores

  Archivos de Cabecera (nuevos/modificados):
    - sysinfo.h        : Estructuras para información del sistema

  Documentación:
    - README           : Este archivo
    - informe.md       : Informe técnico completo y detallado

DOCUMENTACIÓN ADICIONAL:

  Para información técnica detallada sobre la implementación, diseño,
  decisiones técnicas y fragmentos de código comentados, consultar:
  
    informe.md

  El informe incluye:
  - Introducción y objetivos del proyecto
  - Descripción detallada de cada módulo implementado
  - Fragmentos de código relevantes con comentarios extensos
  - Análisis de decisiones de diseño y trade-offs
  - Desafíos técnicos enfrentados y soluciones
  - Conclusiones técnicas y aprendizajes
  - Limitaciones y trabajo futuro

INFORMACIÓN DEL PROYECTO:

  Curso:         Sistemas Operativos
  Fecha:         Diciembre 2025
  Base:          xv6 (MIT PDOS)
  Arquitectura:  x86 (32-bit)
  Lenguaje:      C y Assembly

================================================================================

================================================================================
ENTREGABLE 1: INSTRUMENTACIÓN DE LLAMADAS AL SISTEMA
================================================================================

DESCRIPCIÓN:
Se ha implementado un sistema de trazado de syscalls que permite registrar
y mostrar todas las llamadas al sistema que ejecuta un proceso, incluyendo
el nombre de la syscall, sus argumentos y el valor de retorno.

COMPILACIÓN:
  make clean
  make

EJECUCIÓN:
  make qemu         # Modo gráfico (si QEMU tiene soporte VGA)
  make qemu-nox     # Modo texto (recomendado para servidores sin X11)

COMANDO DE USUARIO:
  trace <comando> [argumentos...]

  Ejecuta el comando especificado con trazado de syscalls activado.
  Solo el comando ejecutado mostrará las syscalls, sin afectar otros procesos.

EJEMPLOS DE USO:
  
  $ trace echo hola
  [PID 3] syscall: trace(0x1, 0x0, 0x0) -> 0x0
  [PID 3] syscall: exec(0x2ff0, 0x2f20, 0x2) -> 0x0
  [PID 3] syscall: write(0x1, 0x2f7f, 0x1)h -> 0x1
  [PID 3] syscall: write(0x1, 0x2f7f, 0x1)o -> 0x1
  [PID 3] syscall: write(0x1, 0x2f7f, 0x1)l -> 0x1
  [PID 3] syscall: write(0x1, 0x2f7f, 0x1)a -> 0x1
  [PID 3] syscall: write(0x1, 0x2f7f, 0x1)
   -> 0x1
  [PID 3] syscall: exit(0x0, 0x0, 0x2fdc)
  hola

  $ trace ls
  [PID 4] syscall: trace(0x1, 0x0, 0x0) -> 0x0
  [PID 4] syscall: exec(0x2ff0, 0x2f20, 0x2) -> 0x0
  [PID 4] syscall: fstat(0x3, 0x2e30, 0x0) -> 0x0
  [PID 4] syscall: read(0x3, 0xc000, 0x200) -> 0x200
  [PID 4] syscall: write(0x1, 0x3f54, 0x2). -> 0x2
  [PID 4] syscall: write(0x1, 0x3f54, 0x7)README -> 0x7
  ...
  [PID 4] syscall: exit(0x0, 0x0, 0x2e94)
  .              1 1 512
  ..             1 1 512
  README         2 2 2227
  ...

  $ trace cat README | head -5
  [PID 5] syscall: trace(0x1, 0x0, 0x0) -> 0x0
  [PID 5] syscall: exec(0x2ff0, 0x2f20, 0x2) -> 0x0
  [PID 5] syscall: open(0x2f80, 0x0, 0x0) -> 0x3
  [PID 5] syscall: read(0x3, 0xc000, 0x200) -> 0x200
  [PID 5] syscall: write(0x1, 0xc000, 0x200) -> 0x200
  ...

  $ trace grep xv6 README
  [PID 6] syscall: trace(0x1, 0x0, 0x0) -> 0x0
  [PID 6] syscall: exec(0x2ff0, 0x2f20, 0x2) -> 0x0
  [PID 6] syscall: open(0x2f85, 0x0, 0x0) -> 0x3
  [PID 6] syscall: read(0x3, 0x4e00, 0x200) -> 0x200
  [PID 6] syscall: write(0x1, 0x3eb8, 0x5)xv6... -> 0x5
  ...
  xv6 is a re-implementation of Dennis Ritchie's...

FORMATO DE SALIDA:
  [PID N] syscall: nombre(arg0, arg1, arg2) -> retorno

  - PID: Identificador del proceso
  - nombre: Nombre de la syscall (fork, exec, read, write, etc.)
  - arg0, arg1, arg2: Primeros tres argumentos en hexadecimal
  - retorno: Valor de retorno en hexadecimal

VERIFICACIÓN DE FUNCIONAMIENTO:
  1. Ejecutar un comando CON trace:
     $ trace echo test
     Debe mostrar líneas de syscalls

  2. Ejecutar un comando SIN trace:
     $ echo test
     NO debe mostrar líneas de syscalls

  3. Verificar aislamiento:
     $ trace ls
     $ ls
     Solo el primero debe mostrar syscalls

SALIR DE QEMU:
  - Presionar: Ctrl+A, luego X
  - O cerrar la ventana del emulador

ARCHIVOS MODIFICADOS:
  - proc.h         : Agregado campo trace_syscalls
  - syscall.h      : Definido SYS_trace
  - syscall.c      : Implementado logging de syscalls
  - sysproc.c      : Implementado sys_trace()
  - proc.c         : Inicialización de trace_syscalls
  - user.h         : Prototipo de trace()
  - usys.S         : Stub de ensamblador
  - trace.c        : Programa de usuario (NUEVO)
  - Makefile       : Agregado _trace a UPROGS

SYSCALL IMPLEMENTADA:
  int trace(int enable)
  - enable=1: Activa el trazado para el proceso actual
  - enable=0: Desactiva el trazado
  - Retorna 0 en éxito, -1 en error

CARACTERÍSTICAS:
  ✓ Trazado por proceso (no global)
  ✓ No se hereda en fork()
  ✓ Se preserva en exec()
  ✓ Muestra nombre, argumentos y retorno
  ✓ No afecta el funcionamiento normal del sistema

================================================================================

================================================================================
ENTREGABLE 2: COMANDOS DE INSPECCIÓN Y MONITOREO DEL SISTEMA
================================================================================

DESCRIPCIÓN:
Se han implementado tres comandos nuevos para inspeccionar el estado del
sistema, procesos y archivos en xv6, orientados a temas de gestión de
procesos, planificación y sistema de archivos.

COMANDOS IMPLEMENTADOS:

1. uptime - ESTADÍSTICAS DEL SISTEMA EXTENDIDO
   Muestra información detallada sobre el estado del sistema:
   - Tiempo de ejecución (ticks y formato HH:MM:SS)
   - Número de procesos por estado (total, running, runnable, sleeping, zombie)
   - Contador de cambios de contexto del planificador

2. ps - INSPECTOR DE PROCESOS
   Lista todos los procesos activos del sistema con:
   - PID (Process ID)
   - Estado (embryo, sleeping, runnable, running, zombie)
   - Tamaño de memoria (SIZE)
   - Nombre del proceso

3. lsx - LISTADO EXTENDIDO DE ARCHIVOS
   Versión extendida de ls que muestra información detallada:
   - Tipo (FILE, DIR, DEV)
   - Número de inode
   - Número de enlaces (hard links)
   - Tamaño en bytes
   - Nombre del archivo/directorio

CASOS DE PRUEBA:

1. Verificar estadísticas del sistema:
   $ uptime

2. Listar procesos en ejecución:
   $ ps

3. Ver archivos con detalle:
   $ lsx

4. Ver archivo específico:
   $ lsx README

SYSCALLS: sysinfo(), getprocs()
ARCHIVOS NUEVOS: uptime.c, ps.c, lsx.c, sysinfo.h

================================================================================

================================================================================
ENTREGABLE 3: CONTADOR DE INVOCACIONES POR SYSCALL
================================================================================

DESCRIPCIÓN:
Se ha implementado un sistema de conteo de invocaciones para cada syscall
del sistema. El kernel mantiene un array global que se incrementa cada vez
que se ejecuta una syscall, y se provee un comando para consultar estos
contadores.

COMANDO IMPLEMENTADO:

syscount - CONTADOR DE INVOCACIONES DE SYSCALLS

  Uso sin parámetros (resumen completo):
    $ syscount
    Muestra una tabla con todas las syscalls y su número de invocaciones

  Uso con parámetro (consulta individual):
    $ syscount <número_syscall>
    Muestra únicamente el contador de la syscall especificada

EJEMPLOS DE USO:

1. Ver resumen completo de todas las syscalls:

   $ syscount
   === CONTADORES DE SYSCALLS ===

   NUM  NOMBRE            INVOCACIONES
   ---  ----------------  ------------
   1    fork              5
   2    exit              4
   5    read              127
   7    exec              8
   11   getpid            3
   16   write             245
   21   close             42
   ...

   TOTAL DE INVOCACIONES: 534

2. Consultar una syscall específica:

   $ syscount 16
   Syscall #16 (write): 245 invocaciones

   $ syscount 1
   Syscall #1 (fork): 5 invocaciones

3. Verificar incremento de contadores:

   $ syscount 5       # read tiene X invocaciones
   $ cat README       # Ejecutar comando que usa read
   $ syscount 5       # read ahora tiene más invocaciones

SYSCALL IMPLEMENTADA:

int syscount(int syscall_num, uint *count_ptr)
  Parámetros:
    - syscall_num: Número de syscall a consultar, o -1 para todas
    - count_ptr: Puntero donde escribir el/los contador(es)
  Retorno:
    - Si syscall_num == -1: retorna tamaño del array
    - Si syscall_num >= 0: retorna 0 en éxito, -1 en error

IMPLEMENTACIÓN:

Array global en el kernel:
  - uint syscall_counts[25]: Array que mantiene contadores
  - Se incrementa en syscall() antes de ejecutar cada syscall
  - Persistente durante toda la ejecución del sistema
  - No se resetea (acumulativo)

Función del kernel:
  - getsysccount(int num, uint *ptr): Copia contador(es) a espacio usuario
  - Validación de rangos y punteros
  - Soporte para consulta individual o completa

ARCHIVOS MODIFICADOS/CREADOS:

Nuevos:
  - syscount.c         : Comando de usuario

Modificados:
  - syscall.h          : Agregado SYS_syscount (25)
  - syscall.c          : Agregado array syscall_counts[]
                       : Incremento en syscall()
                       : Implementado getsysccount()
  - sysproc.c          : Implementado sys_syscount()
  - defs.h             : Declaración de getsysccount()
  - user.h             : Prototipo syscount()
  - usys.S             : Stub de ensamblador
  - Makefile           : Agregado _syscount a UPROGS

CASOS DE PRUEBA:

1. Resumen inicial después de boot:
   $ syscount
   Debe mostrar syscalls básicas (fork, exec, read, write)

2. Consulta de syscall específica:
   $ syscount 16
   Debe mostrar contador de write

3. Verificar incremento tras operación:
   $ syscount 5
   $ cat README
   $ syscount 5
   El contador debe haber aumentado

4. Operaciones múltiples:
   $ syscount          # Ver estado inicial
   $ ls                # Ejecuta varias syscalls
   $ syscount          # Ver incrementos

5. Número inválido:
   $ syscount 100
   Debe mostrar error

NOTAS TÉCNICAS:

- Los contadores son acumulativos desde el boot del sistema
- No hay forma de resetear los contadores
- El contador de syscount() también se cuenta a sí mismo
- Los números de syscall van de 1 a 24 (0 no se usa)
- El array syscall_counts[25] cubre todas las syscalls actuales

NÚMEROS DE SYSCALLS PRINCIPALES:

 1: fork        7: exec       13: sleep      19: link
 2: exit        8: fstat      14: uptime     20: mkdir
 3: wait        9: chdir      15: open       21: close
 4: pipe       10: dup        16: write      22: trace
 5: read       11: getpid     17: mknod      23: sysinfo
 6: kill       12: sbrk       18: unlink     24: getprocs

================================================================================
